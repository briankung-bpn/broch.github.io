<!DOCTYPE html>
<html class="h-100" lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>broch.io - Build Your Own Haskell Web Framework on WAI</title>
        <link rel="stylesheet" href="https://unpkg.com/tachyons@4.9.1/css/tachyons.min.css" />
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66865607-1', 'auto');
  ga('send', 'pageview');
</script>

    </head>
    <body class="h-100 sans-serif">
        <nav class="w-100 tc fixed bg-white top-0 z-3 shadow-4">
            <input id="burger" type="checkbox" class="absolute top-2 right-1 dn">
            <label for="burger" class="dn-l pointer absolute top-1 right-1">
                <svg id="burger-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 23 23" width="23" height="23">
                    <line class="burger-bar" x1="0" y1="5" x2="23" y2="5"></line>
                    <line class="burger-bar" x1="0" y1="13" x2="23" y2="13"></line>
                    <line class="burger-bar" x1="0" y1="21" x2="23" y2="21"></line>
                </svg>
            </label>
            <ul id="main-menu" class="overflow-hidden menu db-l w-100 list tc pl0 pt2 pt3-l mv0 f4 fw3">
                <li class="absolute static-l top-3 pl3 pl0-l pr5 pt2 mh2 f4 f3-ns di-l">
                    <a href="../../" class="link black fw4">
                        <img class="h2-plus v-mid" alt="broch.io logo: black outline plan view of a broch" src="../../images/broch.svg" />
                        <span class="b">broch.io</span>
                    </a>
                </li>
                <li class="ph4 pl5-l pr4-l di-l pt5 pb2 tl pv0-l"><a href="../../" class="link blood-red dim">Home</a></li>
                <!-- >li class="ph4 di-l pv2 tl pv0-l"><a href="/about.html" class="link black dim">About</a></li -->
                <li class="ph4 di-l pv2 tl pv0-l"><a href="../../contact.html" class="link blood-red dim">Contact</a></li>
                <li class="ph4 di-l pv2 tl pv0-l"><a href="../../archive.html" class="link blood-red dim">Archive</a></li>
            </ul>
        </nav>
        <div class="h-100 pt5 mw7 center flex flex-column justify-between">
            <main class="pa3">
                <h1 class="f4 f3-l">Build Your Own Haskell Web Framework on WAI</h1>

                <div class="gray i f5">
Posted on April 19, 2015
 by Luke 

</div>

<p>This article shows how you can build on top of the basic request/response handling functionality provided by <a href="http://hackage.haskell.org/package/wai">WAI</a> and the <a href="http://hackage.haskell.org/package/warp">Warp server</a>, to support some of the requirements you might have in a typical web application. The content is mostly gleaned from my research into the code of several WAI-based web frameworks to try to understand how they work. Building a web application was one of the things I tackled when I didn’t really know Haskell well enough, so hopefully this will be useful if you’re at a similar stage and would like to understand what’s going on in a bit more depth. I’ll outline some of the features these frameworks add, build a similar (but simplified) implementation, and also provide links to the source code of some real-world frameworks built on WAI (such as <a href="http://hackage.haskell.org/package/scotty">Scotty</a>, <a href="http://www.spock.li/">Spock</a> and <a href="http://www.yesodweb.com/">Yesod</a>) for comparison.</p>
<p>Whether you need to use an additional framework on top of WAI will very much depend on your requirements, how complicated your application is and whether you want to track the extra dependencies in your project. Frameworks cater for general cases (making the types more complex for a beginner) and they have a lot of features. You should certainly try out something like Spock or Scotty as they are easy to get started with. For a simple application, or one where you need finer control over handling requests, you might then consider a customized approach. On the other hand, you might overlook something important which the framework authors didn’t <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> – the code in this article is only meant to be a rough outline. If you <em>do</em> decide to “build your own,” please think hard before releasing it to Hackage. There are more than enough WAI frameworks out there already <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<h3 id="basic-wai">Basic WAI</h3>
<p>WAI (“web application interface”) is a Haskell HTTP request/response API. Theoretically it is server-agnostic but in practice it is really only implemented by the warp server.</p>
<p>Request handling in WAI is defined by the <code>Application</code> type <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> :</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Application</span> <span class="fu">=</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span></code></pre></div>
<p>The <a href="http://hackage.haskell.org/package/wai-3.0.2.1/docs/Network-Wai-Internal.html#t:Request"><code>Request</code></a> gives access to the request headers, query string, request body and so on, while the <code>Response -&gt; IO ResponseReceived</code> callback allows us to send a response we have created. A typical WAI example you might come across will show how to send a simple response:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Types</span> (status200)
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span> (run)

<span class="ot">app ::</span> <span class="dt">Application</span>
app _ respond <span class="fu">=</span> respond <span class="fu">$</span>
  responseLBS status200 [(<span class="st">&quot;Content-Type&quot;</span>, <span class="st">&quot;text/plain&quot;</span>)] <span class="st">&quot;hello&quot;</span>

main <span class="fu">=</span> run <span class="dv">3000</span> app</code></pre></div>
<p>So from a web developer’s perspective, a WAI application is a single function which is called for each request and sends back a response. The code runs in the IO monad and there’s no out-of-the-box support for performing redirects, cookie handling, managing sessions or supporting different response types such as text, HTML or JSON. Web frameworks like Scotty and Yesod build these features on top of WAI using their own custom handler monads, meaning you won’t usually call the WAI functions directly in your code. Frameworks also provide some kind of routing DSL, usually based on the request path and method (GET, POST etc.), so you can map different requests to different handler functions.</p>
<h3 id="the-handler-monad">The Handler Monad</h3>
<p>The handler monad provides convenient (read-only) access to the request (headers, parameters) and also provides functions to build the response. This is typically achieved using a combination of <code>ReaderT</code> and <code>StateT</code> monad transformers <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. So we could start with something like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad.Reader</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Types</span> (<span class="dt">ResponseHeaders</span>, <span class="dt">Status</span>)
<span class="kw">import </span><span class="dt">Network.Wai</span> (<span class="dt">Request</span>)


<span class="kw">type</span> <span class="dt">Params</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Text</span> [<span class="dt">Text</span>]

<span class="kw">data</span> <span class="dt">RequestData</span> <span class="fu">=</span> <span class="dt">RequestData</span>
    {<span class="ot"> waiReq ::</span> <span class="dt">Request</span>
    ,<span class="ot"> queryParams ::</span> <span class="dt">Params</span>
    ,<span class="ot"> postParams  ::</span> <span class="dt">Params</span>
    }

<span class="kw">data</span> <span class="dt">ResponseState</span> <span class="fu">=</span> <span class="dt">ResponseState</span>
    {<span class="ot"> resStatus ::</span> <span class="dt">Status</span>
    ,<span class="ot"> resHeaders ::</span> <span class="dt">ResponseHeaders</span>
    ,<span class="ot"> content ::</span> <span class="dt">BL.ByteString</span>
    }

<span class="kw">type</span> <span class="dt">Handler</span> a <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">RequestData</span> (<span class="dt">StateT</span> <span class="dt">ResponseState</span> <span class="dt">IO</span>) a</code></pre></div>
<p><code>RequestData</code> provides access to the original WAI request as well as the parsed request parameters and is accessed via the reader monad. <code>ResponseState</code> stores the status code, headers and response content. Here we’re assuming the only requirement is to handle simple content we can create as a <code>ByteString</code>, so we’re forgetting about streaming responses or serving up files directly. Similarly we’re ignoring file uploads in the request data <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>.</p>
<h3 id="routing">Routing</h3>
<p>Our application will consist of request handler functions written in the <code>Handler</code> monad. We also need some way of mapping different requests to the correct handlers. Frameworks generally include a DSL to do this, often using Sinatra-style verb/path combinations, including support for capturing URL parameters and converting parameters to specific types.</p>
<p>A very simple routing option is to just pattern match on the <code>pathInfo</code> property of the WAI <code>Request</code>, which is of type <code>[Text]</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Router</span> <span class="fu">=</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()</code></pre></div>
<p>We can then build our application as a simple routing table:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAppRouter ::</span> <span class="dt">Router</span>
myAppRouter path <span class="fu">=</span> <span class="kw">case</span> path <span class="kw">of</span>
  [<span class="st">&quot;home&quot;</span>]    <span class="ot">-&gt;</span> myHomePageHandler
  [<span class="st">&quot;login&quot;</span>]   <span class="ot">-&gt;</span> loginHandler
  [<span class="st">&quot;logout&quot;</span>]  <span class="ot">-&gt;</span> logoutHandler
  [<span class="st">&quot;user&quot;</span>, u] <span class="ot">-&gt;</span> userHandler u
  _           <span class="ot">-&gt;</span> notFound</code></pre></div>
<p>For a given request, the router will give us a corresponding handler which we can run. The type is <code>Handler ()</code> since the handler doesn’t return anything. The <code>ResponseState</code> retrieved from the State monad gives us all we need to send the response. This isn’t a very flexible approach, but it’s very easy to understand and fine as a first option if we don’t need to be able to compose routers and so on. You can find routing packages on Hackage but that’s a topic for another time.</p>
<h3 id="running-the-handler">Running the Handler</h3>
<p>What does it actually mean to run the handler? Before we look at the code, we need to make some minor changes to the <code>Handler</code> type to support short-circuiting.</p>
<h4 id="short-circuiting-in-the-handler-monad">Short-Circuiting in the Handler Monad</h4>
<p>In a web application, if we redirect to a different URL, we generally want the response to complete at that point. For example, if we have a request which requires an authenticated user, we might redirect them to a login page if they haven’t logged in, but if they’re already authenticated, we’d want the handler code to proceed. Another obvious short-circuiting case is when something goes wrong during execution and we want to immediately send an error response. If the monad doesn’t short-circuit, then the only alternative is to use nested <code>if/else</code> or <code>case</code> statements to control which code is executed <a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<p>You might also want the monad to short-circuit whenever you write the response content. In “real world” frameworks the behaviour varies so you need to know how each of them work <a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
<p>So how do we make our monad short-circuit? One option is to add the <code>EitherT</code> monad transformer to our existing monad. If you’re not familiar with <code>EitherT</code>, the behaviour is analogous to the familiar <code>Either</code> type <a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>. If we call <a href="http://hackage.haskell.org/package/either-4.3.2/docs/Control-Monad-Trans-Either.html#v:left"><code>left</code></a> (or equivalently <code>throwError</code> since <code>EitherT</code> is a <code>MonadError</code> instance), the monad will short-circuit <a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HandlerResult</span> <span class="fu">=</span> <span class="dt">Redirect</span> <span class="dt">ByteString</span>     <span class="co">-- Redirect to a URL</span>
                   <span class="fu">|</span> <span class="dt">ResponseComplete</span>        <span class="co">-- Send the response</span>
                   <span class="fu">|</span> <span class="dt">HandlerError</span> <span class="dt">ByteString</span> <span class="co">-- Send an internal error response</span>
                     <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">type</span> <span class="dt">Handler</span> a <span class="fu">=</span> <span class="dt">EitherT</span> <span class="dt">HandlerResult</span> (<span class="dt">ReaderT</span> <span class="dt">RequestData</span> (<span class="dt">StateT</span> <span class="dt">ResponseState</span> <span class="dt">IO</span>)) a</code></pre></div>
<p>When we call <code>runEitherT</code> followed by <code>runReaderT</code> and <code>runStateT</code>, the result is of type <code>IO (Either HandlerResult (), ResponseState)</code>.</p>
<h4 id="the-runhandler-function">The <code>runHandler</code> Function</h4>
<p>As things stand now, we have a WAI <code>Request</code> object passed as an argument to the <code>Application</code> type. To process it, we lookup the handler in our <code>Router</code> and then:</p>
<ul>
<li>Create a <code>RequestData</code> from the <code>Request</code></li>
<li>Create an initial <code>ResponseState</code></li>
<li>Run the hander to get back the <code>Either HandlerExcept ()</code> result and the final <code>ResponseState</code></li>
</ul>
<p>The complete <code>runHandler</code> function looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.Wai.Parse</span>

<span class="ot">runHandler ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Response</span>
runHandler req h  <span class="fu">=</span> <span class="kw">do</span>
    (pParams, _) <span class="ot">&lt;-</span> parseRequestBody lbsBackEnd req
    <span class="kw">let</span> initRes <span class="fu">=</span> <span class="dt">ResponseState</span> status200 [] <span class="st">&quot;&quot;</span>
        rd <span class="fu">=</span> <span class="dt">RequestData</span>
              { waiReq      <span class="fu">=</span> req
              , queryParams <span class="fu">=</span> toMap <span class="fu">$</span> fmap (\(n, v) <span class="ot">-&gt;</span> (n, fromMaybe <span class="st">&quot;&quot;</span> <span class="fu">$</span> v)) <span class="fu">$</span> queryString req
              , postParams  <span class="fu">=</span> toMap pParams
              }

    (result, res) <span class="ot">&lt;-</span> runStateT (runReaderT (runEitherT h) rd) initRes
    <span class="kw">let</span> hdrs <span class="fu">=</span> resHeaders res
    return <span class="fu">$</span> <span class="kw">case</span> result <span class="kw">of</span>
        <span class="dt">Left</span> <span class="dt">ResponseComplete</span>   <span class="ot">-&gt;</span> responseLBS (resStatus res) hdrs (content res)
        <span class="dt">Left</span> (<span class="dt">Redirect</span> url)     <span class="ot">-&gt;</span> responseLBS status302 ((hLocation, url) <span class="fu">:</span> hdrs) <span class="st">&quot;&quot;</span>
        <span class="dt">Left</span> (<span class="dt">HandlerError</span> msg) <span class="ot">-&gt;</span> responseLBS internalServerError500 hdrs (BL.fromStrict msg)
        <span class="dt">Right</span> _ <span class="ot">-&gt;</span> error <span class="st">&quot;Not handled&quot;</span>

<span class="ot">toMap ::</span> [(<span class="dt">ByteString</span>, <span class="dt">ByteString</span>)] <span class="ot">-&gt;</span> <span class="dt">Params</span>
toMap <span class="fu">=</span> M.unionsWith (<span class="fu">++</span>) <span class="fu">.</span> map (\(x, y) <span class="ot">-&gt;</span> M.singleton (TE.decodeUtf8 x) [TE.decodeUtf8 y])</code></pre></div>
<p>The function <a href="https://github.com/yesodweb/wai/blob/wai-extra/3.0.3/wai-extra/Network/Wai/Parse.hs#L174"><code>parseRequestBody</code></a> is part of the <a href="http://hackage.haskell.org/package/wai-extra"><code>wai-extra</code></a> library. It attempts to parse the request body as <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4">HTML Form data</a>, returning a tuple containing a list of submitted parameters and a list of uploaded files. Since we aren’t supporting file uploads we ignore the second element of the tuple. If the request <code>content-type</code> is neither <code>application/x-www-form-urlencoded</code> nor <code>multipart/form-data</code>, then both these arrays will be empty and we need to read and parse the request body ourselves. We’ll look at this below.</p>
<p>Note that we’re taking the approach that <em>all</em> responses should short-circuit and assume it’s a programmer error if the handler doesn’t redirect, write a response or return an error message. This might be confusing if you’re used to the <code>Left</code> constructor of <code>Either</code> being the “error” case, but it’s really just the case that short-circuits <a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>.</p>
<h3 id="functions-in-the-handler-monad">Functions in the Handler Monad</h3>
<p>The handler monad is not very useful by itself. We want to hide the details behind a convenient API for reading request properties and creating the response. We’ll look at some simple examples, but you can obviously write whatever functions best suit your needs.</p>
<h4 id="reading-the-request">Reading the request</h4>
<p>When processing a request, we typically want to read parameters and/or the request body. Most frameworks do not differentiate between different types of request parameters, but let’s suppose we want to treat request body parameters separately from query string parameters <a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>. We’ll also assume that it’s an error to send duplicate values of the same parameter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">postParam ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Text</span>
postParam name <span class="fu">=</span> asks postParams <span class="fu">&gt;&gt;=</span> lookupParam name

<span class="ot">queryParam ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Text</span>
queryParam name <span class="fu">=</span> asks queryParams <span class="fu">&gt;&gt;=</span> lookupParam name

<span class="ot">lookupParam ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Params</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Text</span>
lookupParam name params <span class="fu">=</span> <span class="kw">case</span> M.lookup name params <span class="kw">of</span>
    <span class="dt">Just</span> [v] <span class="ot">-&gt;</span> return v
    _        <span class="ot">-&gt;</span> throwError <span class="fu">$</span> <span class="dt">HandlerError</span> <span class="fu">$</span> B.concat [<span class="st">&quot;Missing or duplicate parameter&quot;</span>, TE.encodeUtf8 name]</code></pre></div>
<p>WAI’s <code>Request</code> record type has a field called <code>requestBody</code> which is of type <code>IO ByteString</code>. It produces the complete body a chunk at a time, returning an empty <code>ByteString</code> when the body is completely consumed. There’s also a convenience function to do this, which we can wrap to create our <code>body</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">body ::</span> <span class="dt">Handler</span> <span class="dt">BL.ByteString</span>
body <span class="fu">=</span> asks waiReq <span class="fu">&gt;&gt;=</span> liftIO <span class="fu">.</span> strictRequestBody</code></pre></div>
<p>Note that the body can only be read once. It may already have been read by the function <code>parseRequestBody</code> which we used above and in that case, the <code>body</code> function would return an empty value <a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a>.</p>
<h4 id="building-the-response">Building the response</h4>
<p>For the response, we’ll start by writing functions to:</p>
<ul>
<li>redirect to another URL</li>
<li>set the status</li>
<li>set the content as text, JSON, HTML</li>
</ul>
<p>The redirect function just takes a URL as a <code>ByteString</code> and short-circuits with the corresponding <code>HandlerResult</code> value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">redirect ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> a
redirect <span class="fu">=</span> throwError <span class="fu">.</span> <span class="dt">Redirect</span></code></pre></div>
<p>The <code>runHandler</code> function we wrote above does the rest of the work, setting the status code to 302 and the <code>Location</code> header to the supplied URL.</p>
<p>Setting the response status to a different value is easily done by changing the state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">status ::</span> <span class="dt">Status</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()
status s <span class="fu">=</span> modify <span class="fu">$</span> \rs <span class="ot">-&gt;</span> rs { resStatus <span class="fu">=</span> s }</code></pre></div>
<p>and we can write the response content as text, JSON or (Blaze) HTML using the following functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Text.Blaze.Html</span> (<span class="dt">Html</span>)
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Utf8</span> (renderHtml)

<span class="ot">text ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()
text t <span class="fu">=</span> setContentType <span class="st">&quot;text/plain; charset=utf-8&quot;</span> <span class="fu">&gt;&gt;</span> (rawBytes <span class="fu">.</span> BL.fromStrict <span class="fu">$</span> TE.encodeUtf8 t)

<span class="ot">json ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()
json j <span class="fu">=</span> setContentType <span class="st">&quot;application/json&quot;</span> <span class="fu">&gt;&gt;</span> rawBytes (encode j)

<span class="ot">html ::</span> <span class="dt">Html</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()
html h <span class="fu">=</span> setContentType <span class="st">&quot;text/html; charset=utf-8&quot;</span> <span class="fu">&gt;&gt;</span> rawBytes (renderHtml h)

<span class="ot">rawBytes ::</span> <span class="dt">BL.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()
rawBytes b <span class="fu">=</span> modify (\rs <span class="ot">-&gt;</span> rs { content <span class="fu">=</span> b }) <span class="fu">&gt;&gt;</span> throwError <span class="dt">ResponseComplete</span>

<span class="ot">setHeader ::</span> <span class="dt">HeaderName</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()
setHeader name value <span class="fu">=</span> modify <span class="fu">$</span> \rs <span class="ot">-&gt;</span> rs { resHeaders <span class="fu">=</span> (name, value) <span class="fu">:</span> resHeaders rs }

<span class="ot">setContentType ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> ()
setContentType <span class="fu">=</span> setHeader <span class="st">&quot;Content-Type&quot;</span></code></pre></div>
<h2 id="exception-handling">Exception Handling</h2>
<p>So far we’ve assumed that every <code>Handler</code> will produce a value of type <code>Either HandlerResult ()</code>, but what happens if the code throws an exception instead? We can test this easily by just adding the following route to our <code>myAppRouter</code> above:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="st">&quot;eek&quot;</span>]  <span class="ot">-&gt;</span> error <span class="st">&quot;eek!&quot;</span></code></pre></div>
<p>Requesting the URL <code>/eek</code> from a browser returns the text response “Something went wrong” with a 500 response code. This is the default response produced by Warp’s internal error handler and it is easily customized <a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a>. Alternatively we can catch the exception ourselves. We still need a function to convert our router into an <code>Application</code>, so we can do it there:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">routerToApplication ::</span> <span class="dt">Router</span> <span class="ot">-&gt;</span> <span class="dt">Application</span>
routerToApplication route req respond <span class="fu">=</span>
  (runHandler req <span class="fu">$</span> route pathInfo req)
    <span class="ot">`catch`</span> λ(<span class="ot">e ::</span> <span class="dt">SomeException</span>) <span class="ot">-&gt;</span> return <span class="fu">$</span> responseLBS internalServerError500 [] <span class="fu">$</span> <span class="st">&quot;Internal error&quot;</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Even though WAI is not really a standard web interface supported by multiple servers, it <em>is</em> common to multiple frameworks so an understanding WAI and Warp is useful if you are likely to be developing Haskell web applications.</p>
<p>In this article we’ve built a simple set of functions with which we can write web handlers which would look quite similar to those of a framework like Scotty, and you should now hopefully have a clearer idea of how they work. The code is available from the accompanying samples repository <a href="https://github.com/broch/brochio-samples/blob/byowai/ByoWai.hs">on github</a>, on the <code>byowai</code> branch. The branch commit history closely follows the structure of the article and should compile at each stage. For a more complex example, you can also see this kind of code in use in a project I’ve been working on which is an implementation of the <a href="http://openid.net/developers/specs/">OpenID Connect specification</a> in Haskell <a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>. I’ll hopefully find time to write up more articles on this topic as the development proceeds.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Warp doesn’t automatically limit the request size, for example, so someone can crash your application by sending a very large request. For example, you can use the curl command <code>curl -v --data-urlencode 'username@my_giant_file.txt' localhost:3000/login</code> to send a large file as a parameter. See also, Yesod’s <code>maximumContentLength</code> setting, which it uses to <a href="https://github.com/yesodweb/yesod/blob/yesod-core/1.4.6/yesod-core/Yesod/Core/Internal/Request.hs#L55">limit the request body size</a>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://hackage.haskell.org/package/scotty">Scotty</a>, <a href="http://www.yesodweb.com/">Yesod</a>, <a href="http://hackage.haskell.org/package/hails">Hails</a>, <a href="http://hackage.haskell.org/package/apiary">Apiary</a>, <a href="http://www.spock.li/">Spock</a>, <a href="http://hackage.haskell.org/package/Wheb">Wheb</a>, <a href="http://hackage.haskell.org/package/simple">Simple</a>. For a more complete list, you can look through <a href="http://packdeps.haskellers.com/reverse/warp">Warp’s reverse dependencies</a>.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>For a good overview of WAI, see the <a href="http://www.yesodweb.com/book-1.4/web-application-interface">Yesod Book</a>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>The <a href="https://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-RWS-Strict.html#g:2">RWST</a> monad transformer is another possibility and is used by the <a href="https://github.com/agrafix/Spock/blob/0.7.5.1/src/Web/Spock/Internal/Wire.hs#L89">Spock Framework</a>. In this case the “writer” part of the monad is ignored.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>For an example which builds its own monad from scratch, see Apiary’s <a href="http://hackage.haskell.org/package/apiary-1.2.0/docs/src/Control-Monad-Apiary-Action-Internal.html#ActionT"><code>ActionT</code></a> or Simple’s <a href="https://github.com/alevy/simple/blob/v0.9.0.0/simple/src/Web/Simple/Controller/Trans.hs#L51"><code>ControllerT</code></a>.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>You’ll see these extra request and response data options in Scotty’s <a href="https://github.com/scotty-web/scotty/blob/0.9.0/Web/Scotty/Internal/Types.hs#L108"><code>ActionEnv</code> and <code>Content</code></a> types, for example.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>If we look at the type signatures for the <code>redirect</code> functions in existing frameworks, the handler monad is parameterized with an arbitrary type. In Scotty, for example, the type is <code>redirect :: Text -&gt; ActionM a</code> so we can immediately deduce that <code>redirect</code> <em>must</em> short-circuit since it can’t return an arbitrary value.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Scotty <a href="https://github.com/scotty-web/scotty/blob/0.9.0/Web/Scotty/Action.hs#L273">doesn’t complete the response</a> when you write the content using a function like <code>text</code> or <code>json</code> whereas <a href="https://github.com/agrafix/Spock/blob/0.7.5.1/src/Web/Spock/Internal/CoreAction.hs#L210">Spock does</a>. A list of Yesod handler functions which short-circuit can be found in the <a href="http://www.yesodweb.com/book-1.4/routing-and-handlers">Routing and Handlers</a> chapter of the Yesod book.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p><code>EitherT</code> can be found in the <a href="http://hackage.haskell.org/package/either"><code>either</code></a> package and is also re-exported by the <code>errors</code> package.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>You may notice that <code>ExceptT</code> is <a href="https://github.com/scotty-web/scotty/blob/master/Web/Scotty/Internal/Types.hs#L137">used in practice</a> instead of <code>EitherT</code>. However, this requires version 2.2.1 or later of the <code>mtl</code> library, which in turn requires the use of <code>transformers 0.4.*</code>. GHC 7.8 comes with transformers 0.3 so you can end up with conflicting versions in your project if it depends on GHC and cabal will complain. <code>EitherT</code> does the same job, more or less, so we stick with that for now.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>It’s also confusing that the naming conventions often reinforce this. For example, Scotty’s <a href="https://github.com/scotty-web/scotty/blob/0.9.0/Web/Scotty/Internal/Types.hs#L76"><code>ActionError</code></a> type deals with both redirects and errors.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>For example, we might want to report an error if sensitive data like a password is sent in a URL. We couldn’t do this using Scotty’s <code>param</code> function, for instance.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>Scotty <a href="https://github.com/scotty-web/scotty/blob/0.9.0/Web/Scotty/Route.hs#L137">reads the request body</a> and stores it along with the other request data so that it can be accessed more than once.<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>The <a href="http://hackage.haskell.org/package/warp-3.0.5/docs/Network-Wai-Handler-Warp.html#v:setOnExceptionResponse"><code>setOnExceptionResponse</code></a> setting can be used for customization. The exception is caught and the response sent in the <a href="https://github.com/yesodweb/wai/blob/warp/3.0.5/warp/Network/Wai/Handler/Warp/Run.hs#L282"><code>serveConnection</code></a> function. The exception is then re-thrown to the <code>fork</code> function which <a href="https://github.com/yesodweb/wai/blob/warp/3.0.5/warp/Network/Wai/Handler/Warp/Run.hs#L256">calls the exception handler</a> configured with <a href="http://hackage.haskell.org/package/warp-3.0.5/docs/Network-Wai-Handler-Warp.html#v:setOnException"><code>setOnException</code></a> and cleans up resources.<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>The project is also on <a href="https://github.com/tekul/broch">github</a>. It’s a work in progress but also includes session handling, for example.<a href="#fnref15">↩</a></p></li>
</ol>
</div>

            </main>
            <footer class="pb4 pr2 f6 i gray tr">
                Site generated by
                <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            </footer>
        </div>
    </body>
</html>
